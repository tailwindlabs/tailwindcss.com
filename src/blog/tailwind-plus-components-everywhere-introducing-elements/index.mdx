import { philippspiess } from "@/app/blog/authors";
import card from "./card.jpg";
import Image from "next/image";
import demo from "./demo.png";

export const meta = {
  title: "Tailwind Plus components, everywhere: Introducing Elements",
  description:
    "Introducing Elements â€” universal UI components that work in any framework with native web platform features.",
  date: "2025-07-22T18:00:00.000Z",
  authors: [philippspiess],
  image: card,
  excerpt: (
    <>
      What if every Tailwind Plus component worked in any framework, with full interactivity? Today we're introducing
      Elements - universal UI components that harness the power of the modern web platform to work everywhere.
    </>
  ),
};

This is an exciting week at Tailwind Labs. For one, it's my one year anniversary (ðŸ¥³) but more importantly: We're shipping something that fundamentally changes how you can use Tailwind Plus.

Here's the challenge we've been facing: We've been building UI components for years now, but there's always been this awkward dance. You love Tailwind Plus, but you're building with Rails/Laravel/SvelteKit or one of the many other web frameworks and every time you try to use a more complicated component, you'd have to either manually wire up JavaScript or just... not have interactivity.

Well, today, that dance is over.

## Introducing Elements

Tailwind Plus Elements is our new foundation for building accessible, interactive UI components that work with any framework and is built on top of the web platform. It's a love letter to the modern web that leverages native features like `<dialog>`, the `popover` property, command invokers, and more.

It was built from the ground up to power all interactive Tailwind Plus components with a declarative API:

<Image alt="" src={demo} />

To get started, all you need to do is to follow one of the two installation options.

### 1. Adding a script tag to your HTML:

You can use the CDN url to load Elements into your app:

```html
<script src="https://cdn.jsdelivr.net/npm/@tailwindplus/elements@1" type="module"></script>
```

### 2. Installing via npm and importing it in your frontend:

Alternatively, if your framework already bundles JavaScript, you can also install it as an npm package:

```bash
npm install @tailwindplus/elements@1
```

Once you've loaded Elements into your app, you can continue using Tailwind Plus as you normally would and just copy and paste the new components into your app. No matter, if you are using a server-side or a client-side framework (or something in between).

### Overview of components

Here's a quick overview of the components included in Elements:

- **Autocomplete**: An accessible autocomplete component that allows users to prefill the input from a list of options. The component behaves like a native datalist with enhanced styling and accessibility features.
- **Command**: An accessible command (combobox) component that allows users to filter and select from a list of items.
- **Dialog**: A fully-managed, renderless dialog component jam-packed with accessibility and keyboard features, perfect for building completely custom dialogs and alerts.
- **Disclosure**: A simple, accessible foundation for building custom UIs that show and hide content, like togglable accordion panels.
- **Dropdown menu**: Menus offer an easy way to build custom, accessible dropdown components with robust support for keyboard navigation.
- **Listbox**: Listboxes are a great foundation for building custom, accessible select menus for your app, complete with robust support for keyboard navigation.
- **Popover**: Popovers are perfect for floating panels with arbitrary content like navigation menus, mobile menus and flyout menus.
- **Tabs**: Easily create accessible, fully customizable tab interfaces, with robust focus management and keyboard navigation support.

You can learn more about each component in the [Elements documentation](https://tailwindcss.com/plus/ui-blocks/documentation/elements-api-reference).

## Embracing the Platform

When building Elements, we've decided early on that we want to lean heavily into the platform. This allows us to avoid a lot of complexity that regular UI libraries need to carry around (e.g. by implementing custom focus management) but also to make a library that _will get smaller as the web evolves_: Most of the file size of Elements right now are polyfills for modern browser APIs that are already shipping on modern browsers.

Here's an overview of some of the modern browser features that Element builds on:

- The `popover` attribute to manage overlays and popovers with automatic top-layer rendering (together with `beforetoggle` to control transitions)
- Modal `<dialog>` elements for the implementation of focus trapping and top-layer rendering
- Invoker commands to declaratively manage interactive elements (like toggling a disclosure)
- Custom elements for a declarative API and `ElementInternals` to manage form association.

Elements builds upon those standard APIs but adds all the features that you expect from a modern component library like being able to click outside a dialog to close it, select a listbox item in one mouse interaction, or fully support exit transitions for dialogs on every browser.

One of the biggest issues when dealing with APIs like custom components is the lack of control over server-side rendered HTML. The JavaScript associated with custom elements is only loaded once the page has been parsed, which can lead to a flash of unstyled content (FOUC) when the page is first loaded. To mitigate this, our Tailwind Plus components now come with additional properties to control the initial page load:

- Tabs have a `hidden` attribute on unselected tab panels. In fact, the way we detect the default tab panel is by checking for the first panel that is not `hidden`.
- All popovers require you to add a `popover` attribute to the element that triggers the popover behavior (making it hidden on initial load).
- Dialogs require you to include a `<dialog>` element for the same reason.
- `<el-selectedcontent>`, an element that is used to render the currently selected content inside the button of a listbox, can be initialized with static HTML to render in the initial load.

Elements targets [the same browsers that Tailwind CSS v4 supports](https://tailwindcss.com/docs/compatibility).

## Custom elements, everywhere

One benefit of the custom elements API is that it works, [no matter the framework](https://custom-elements-everywhere.com/). This means that you can use these components without having to learn a new API.

Let's look at some examples of how to use Elements in different frameworks.

### Autocomplete in Svelte

Since `<el-autocomplete>` enhances a regular `<input type="text">` field (similar to a [`<datalist>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/datalist) component), you can use your regular two-way bindings while still getting all the customizability and accessibility you expect in 2025:

```svelte
<script>
  let input = $state("");
  function handleSubmit() {
    alert(`Selected: ${input}`);
  }
</script>

<form onsubmit={handleSubmit}>
  <el-autocomplete>
    <input bind:value={input} name="selected" placeholder="Type to search..." />
    <button aria-label="Show options">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M15.75 19.5L8.25 12l7.5-7.5" />
      </svg>
    </button>
    <el-options transition popover anchor="bottom start">
      <el-option value="Wade Cooper">Wade Cooper</el-option>
      <el-option value="Tom Cooper">Tom Cooper</el-option>
      <el-option value="Jane doe">Jane Doe</el-option>
    </el-options>
  </el-autocomplete>

  <button type="submit">Submit</button>
</form>
```

### Listboxes in Laravel Livewire

`<el-listbox>` implements a form-associated custom element and fires `change` events (just like regular `<select>` element). This allows you to wire it up just like any other input field in Livewire:

```php
<?php

namespace App\Livewire;

use Livewire\Component;

class Listbox extends Component {
  public $option = 'banana';
  public $options = [
    'banana' => 'Banana',
    'strawberry' => 'Strawberry',
    'apple' => 'Apple',
    'orange' => 'Orange',
  ];

  public function render() {
    return view('livewire.listbox');
  }
}
```

```blade
<el-listbox name="my-list" wire:model.change="option">
  <button>
    <el-selectedcontent>
      {{ $options[$option] }}
    </el-selectedcontent>
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M15.75 19.5L8.25 12l7.5-7.5" />
    </svg>
  </button>
  <el-options anchor="bottom" popover="">
    @foreach ($options as $key => $value)
      <el-option value="{{ $key }}">{{ $value }}</el-option>
    @endforeach
  </el-options>
</el-listbox>
```

### Dropdown menus in Next.js

Of course, you can also use Elements in the community's favorite framework: React. Because everything is built on standard web technology, you can use Next.js `<Link />` components inside your `<el-dropdown>` and it just _works_:

```jsx
import Link from "next/link";

export default function Home() {
  return (
    <el-dropdown>
      <button>Menu</button>
      <el-menu anchor="bottom start" popover>
        <Link href="/">Home</Link>
        <Link href="/about">About</Link>
        <Link href="/faq">FAQ</Link>
      </el-menu>
    </el-dropdown>
  );
}
```

## Looking Forward

Tailwind Plus Elements is available for all [Tailwind Plus customers](https://tailwindcss.com/plus) starting today and we've updated all of our current components to make full use of it.

With Elements, we now have a way to make all of our Tailwind Plus components work in _any_ framework, designed to become lighter as the web platform itself matures.

We can't wait to see what you'll build with it!
