import { philippspiess } from "@/app/blog/authors";
import card from "./card.jpg";
import Image from "next/image";
import select from "./select.png";
import popover from "./popover.png";
import { YouTubeVideo, Video } from "@/components/media";
import commandPalette from "./command-palette.png";
import { Figure } from "@/components/figure";
import { Example } from "@/components/example";
import { CodeExampleStack } from "@/components/code-example";


export const meta = {
  title: "Vanilla JavaScript support for Tailwind Plus",
  description:
    "We're shipping something that people have been asking for _forever_: Vanilla JavaScript support for our HTML components",
  date: "2025-07-22T18:00:00.000Z",
  authors: [philippspiess],
  image: card,
  excerpt: (
    <>
      When we first launched Tailwind UI back in 2020, we didn't ship any JavaScript with our components at all — they
      were just plain HTML snippets. However, anyone building anything real knows that you need at least some JavaScript
      for things like dropdown menus, dialogs, popovers, and other components like that. Which is why in 2021 we added
      support for React and Vue to our components, using our Headless UI library to power them. But, our plain HTML
      components remained the same — you still had to manually wire up your own JavaScript, and for anyone using
      Rails/Laravel/Svelte etc., that was a real pain.
    </>
  ),
};



<YouTubeVideo id="HTFHoA12MJk" />

There are a lot of UI blocks in Tailwind Plus that need JavaScript to really be useful, like dialogs, dropdowns, command palettes, and more. And unless you're a React or Vue user, using those UI blocks meant writing all of that JavaScript yourself.

Well today that finally changes — **every UI block in Tailwind Plus is now fully functional, accessible, and interactive**, including the plain HTML examples.

<Video src="https://assets.tailwindcss.com/blog/vanilla-js-support-for-tailwind-plus/intro-video.mp4" videoClasses="aspect-[1536/804] object-cover"/>

```html
<el-dropdown class="relative inline-block text-left">
  <button class="inline-flex w-full justify-center gap-x-1.5 rounded-md bg-white px-3 py-2 text-sm font-semibold text-gray-900 shadow-xs ring-1 ring-gray-300 ring-inset hover:bg-gray-50">
    Options
    <svg viewBox="0 0 20 20" fill="currentColor" data-slot="icon" aria-hidden="true" class="-mr-1 size-5 text-gray-400">
      <path d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" fill-rule="evenodd" />
    </svg>
  </button>

  <el-menu anchor="bottom end" popover class="w-56 origin-top-right rounded-md bg-white shadow-lg ring-1 ring-black/5 transition transition-discrete [--anchor-gap:--spacing(2)] focus:outline-hidden data-closed:scale-95 data-closed:transform data-closed:opacity-0 data-enter:duration-100 data-enter:ease-out data-leave:duration-75 data-leave:ease-in">
    <div class="py-1">
      <a href="#" class="block px-4 py-2 text-sm text-gray-700 focus:bg-gray-100 focus:text-gray-900 focus:outline-hidden">Account settings</a>
      <a href="#" class="block px-4 py-2 text-sm text-gray-700 focus:bg-gray-100 focus:text-gray-900 focus:outline-hidden">Support</a>
      <a href="#" class="block px-4 py-2 text-sm text-gray-700 focus:bg-gray-100 focus:text-gray-900 focus:outline-hidden">License</a>
      <form action="#" method="POST">
        <button type="submit" class="block w-full px-4 py-2 text-left text-sm text-gray-700 focus:bg-gray-100 focus:text-gray-900 focus:outline-hidden">Sign out</button>
      </form>
    </div>
  </el-menu>
</el-dropdown>
```

Now you can use any [dropdown](https://tailwindcss.com/plus/ui-blocks/application-ui/elements/dropdowns), [command palette](https://tailwindcss.com/plus/ui-blocks/application-ui/navigation/command-palettes), [dialog](https://tailwindcss.com/plus/ui-blocks/application-ui/overlays/modal-dialogs), [drawer](https://tailwindcss.com/plus/ui-blocks/application-ui/overlays/drawers), and more in any project you're working on — no JavaScript framework required.


## No framework required

To pull this off, we built `@tailwindplus/elements` — a library we're releasing exclusively for Tailwind Plus customers.

Elements is a collection of headless [custom elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements) that wrap up all of the complex behavior needed to build custom interactive UIs and can be styled any way you like using utility classes or custom CSS.

Instead of being coupled to a specific JavaScript framework, these custom elements work anywhere you can use a `<script>` tag:

```html
/* [!code filename:index.html] */
<script src="https://cdn.jsdelivr.net/npm/@tailwindplus/elements@1" type="module"></script>
```

Or you can install them via npm if your project has a build pipeline:

<CodeExampleStack>

```sh
/* [!code filename:Shell] */
npm i @tailwindplus/elements
```

```js
/* [!code filename:app.js] */
import '@tailwindplus/elements';
```

</CodeExampleStack>


## Leveraging the modern web

- Using new/upcoming platform features (with polyfills) to write as little custom JS as possible
  - No portals, native dialogs, native popover behavior, etc.

## Components that work everywhere

- Show examples of using these comopnents in Rails, Svelte, even React

## Try it out today

- Explain how this is available to all Tailwind Plus customers
- Link to docs again


---


{/*

This is an exciting week at Tailwind Labs: Not only is it my first anniversary, but we're also shipping something that people have been asking for _forever_: Vanilla JavaScript support for our HTML components.

When we first launched Tailwind UI back in 2020, we didn't ship any JavaScript with our components at all — they were just plain HTML snippets. However, anyone building anything real knows that you need at least some JavaScript for things like dropdown menus, dialogs, popovers, and other components like that. Which is why in 2021 we added support for React and Vue to our components, using our Headless UI library to power them.

But, even though one fourth of all Tailwind Plus components requires some form of interactivity, our plain HTML components remained the same — you still had to manually wire up your own JavaScript, and for anyone using Rails/Laravel/Svelte etc., that was a real pain.

Well, as of today, that's no longer the case.

*/}

## Look mom, no framework!

To pull this off, we built a library of headless [custom elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements) that wrap up all of the necessary behavior and can be styled any way you like using utility classes or custom CSS.

_Explain adding the library via CDN or npm._

Here's what a few of these interactive UI blocks look like in Tailwind Plus, no React, Vue, Svelte, Solid, or Angular needed — just a script tag at the top of your website and some simple, declarative HTML.

{/*
## Tailwind Plus, without React or Vue

You can now use all Tailwind Plus components, with full interactivity, without using React or Vue. To do this, we're introducing Tailwind Plus Elements, a new UI library that can be installed by only adding a single script tag to your website.

Let's take a look at some examples.
*/}


### Custom select

Our new custom select component behaves like a native `<select>` tag, including the form association, but allows for much more control over styling. It's inspired by the upcoming [customizable select](https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Customizable_select) APIs making it easy to remove in the future as they become more widely available.

<Video src="https://assets.tailwindcss.com/blog/vanilla-js-support-for-tailwind-plus/select.mp4" alt="Select" />

```html
<el-select name="selected" value="published">
  <div class="flex ...">
    <el-selectedcontent class="text-sm">Published</el-selectedcontent>
    <button type="button" aria-label="Change published status" class="inline-flex items-center ...">⌄</button>
  </div>

  <el-options anchor="bottom end" popover class="w-72 ...">
    <el-option value="published" class="group/option ...">
      <div class="flex justify-between">
        <p>Published</p>
        <span class="group-not-aria-selected/option:hidden in-[el-selectedcontent]:hidden">✓</span>
      </div>
      <p class="mt-2 text-gray-500 group-focus/option:text-indigo-200 in-[el-selectedcontent]:hidden">
        This job posting can be viewed by anyone who has the link.
      </p>
    </el-option>
    <el-option value="draft" class="group/option ...">
      <div class="flex justify-between">
        <p>Draft</p>
        <span class="group-not-aria-selected/option:hidden in-[el-selectedcontent]:hidden">✓</span>
      </div>
      <p class="mt-2 text-gray-500 group-focus/option:text-indigo-200 in-[el-selectedcontent]:hidden">
        This job posting will no longer be publicly accessible.
      </p>
    </el-option>
  </el-options>
</el-select>
```

### Popover

Our popover element builds upon the native `popover` attribute but adds additional features you'd expect like being able to control that the popover is closing only when the focus leaves a designated popover group.

<Video src="https://assets.tailwindcss.com/blog/vanilla-js-support-for-tailwind-plus/popover.mp4" alt="Popover" />

```html
<header>
  <nav aria-label="Global" class="mx-auto flex max-w-6xl ...">
    <el-popover-group class="hidden lg:flex lg:gap-x-12">
      <div class="relative">
        <button popovertarget="desktop-menu-product" class="flex ...">Product</button>
        <el-popover
          id="desktop-menu-product"
          anchor="bottom"
          popover
          class="w-screen max-w-md transition transition-discrete ..."
        >
          <div class="p-4">
            <div class="group relative flex items-center ...">
              <div class="flex-auto">
                <a href="#" class="text-gray-900">Analytics</a>
                <p class="mt-1 text-gray-600">Get a better understanding of your traffic</p>
              </div>
            </div>
            <!-- ... -->
          </div>
        </el-popover>
      </div>
      <a href="#" class="text-sm/6 text-gray-900">Features</a>
      <a href="#" class="text-sm/6 text-gray-900">Marketplace</a>
      <a href="#" class="text-sm/6 text-gray-900">Company</a>
    </el-popover-group>
    <div class="hidden lg:flex lg:flex-1 lg:justify-end">
      <a href="#" class="text-sm/6 text-gray-900">Log in <span aria-hidden="true">→</span></a>
    </div>
  </nav>
</header>
```

### Command palette

One of the trickier components to convert in Tailwind Plus was the command palette examples because of the many interactive pieces. We are pleasantly surprised how nicely a declarative API came together for it:

<Video
  src="https://assets.tailwindcss.com/blog/vanilla-js-support-for-tailwind-plus/command-palette.mp4"
  alt="Command Palette"
/>

```html
<button command="show-modal" commandfor="dialog" class="rounded-md ...">Open command palette</button>

<el-dialog class="group/dialog">
  <dialog id="dialog" class="backdrop:bg-transparent">
    <div class="fixed inset-0 bg-gray-500/25 ..."></div>

    <div tabindex="0" class="fixed inset-0 w-screen ...">
      <el-dialog-panel class="mx-auto transition group-data-closed/dialog:scale-95 ...">
        <el-command-palette>
          <input type="text" autofocus placeholder="Search..." />

          <el-command-list>
            <el-defaults>
              <h2 class="mt-4 text-gray-500">Recent searches</h2>
              <div class="text-sm text-gray-700">
                <a href="#" class="group flex rounded-md ...">
                  <span class="ml-3 truncate">Workflow Inc. / Website Redesign</span>
                </a>
              </div>

              <div class="p-2">
                <h2 class="sr-only">Quick actions</h2>
                <div class="text-sm text-gray-700">
                  <a href="#" class="group flex rounded-md ...">
                    <span class="ml-3 truncate">Add new file...</span>
                  </a>
                  <!-- ... -->
                </div>
              </div>
            </el-defaults>

            <el-command-group hidden class="block p-2 text-sm text-gray-700">
              <a href="#" hidden class="group flex rounded-md ...">
                <span class="ml-3 truncate">Workflow Inc. / Website Redesign</span>
              </a>
              <!-- ... -->
            </el-command-group>
          </el-command-list>

          <el-no-results hidden class="text-center">
            We couldn't find any projects with that term. Please try again.
          </el-no-results>
        </el-command-palette>
      </el-dialog-panel>
    </div>
  </dialog>
</el-dialog>
```

### And so many more

This is just a brief example of some of the components, but as of today, every Tailwind Plus component is now available with full interactivity, regardless of the framework you're using.

## Embracing the platform

When building Elements, we've decided early on that we want to lean heavily into the web platform. This allows us to avoid a lot of complexity that's typically required for UI libraries like this in the past. For example: implementing modal dialogs requires managing focus so that you can not target elements behind the dialog — This is something that native `<dialog>` elements can do for free.

Here's an overview of some of the modern browser features that Elements is built on:

- The [`popover` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/popover) to manage overlays and popovers with automatic top-layer rendering together with [the `beforetoggle` event](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/beforetoggle_event) to control transitions.
- Modal [`<dialog>` elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement) for the implementation of focus trapping and top-layer rendering.
- [Invoker commands](https://developer.mozilla.org/en-US/docs/Web/API/Invoker_Commands_API) to declaratively manage interactive elements (like toggling a custom disclosure).
- [Custom elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements) (a way to extend HTML elements with custom behavior) for declarative APIs and [`ElementInternals`](https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals) to manage form association.

We also make sure that appropriate polyfills for these features are added and target [the same browsers that Tailwind CSS v4 supports](https://tailwindcss.com/docs/compatibility#browser-support). In theory, this also means Elements should _only get smaller_ as the web continues to evolve and we have to include fewer polyfills.

There are some additional platform APIs that we're pretty excited about but haven't made it into Elements _yet_. One example is [CSS anchor positioning](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_anchor_positioning) where the required polyfill would unfortunately be too limiting currently so we've decided to use a more established third-party library ([Floating UI](https://floating-ui.com/)) for now.

## Server-side rendering

One of the biggest differences when working with fully declarative APIs in HTML is the lack of control over the server-side rendered output. When you include both a dropdown button _and its content_ in the initial HTML payload, the first render would include the content of both elements before the JavaScript associated can hide it leading to flashes of unstyled content (FOUC). Frontend libraries can get away with this by adding the content to the DOM at runtime but we wanted elements to work even if you only use a server-side rendered framework.

We designed Elements in a way that allows you to fully control this initial rendering experience and our Tailwind Plus components come with the required properties. Here are some examples:

- Tabs have a `hidden` attribute on unselected tab panels, ensuring that only the default selected tab panel will be visible.
- Dropdown menus, select inputs, popovers, and other components add an explicit `popover` attribute to the HTML snippet, hiding the content on initial load.
- Dialogs include a `<dialog>` element inside the markup as the browser knows not to show these by default.
- `<el-selectedcontent>`, an element that is used to render the currently selected content inside the trigger of a select, can be initialized with static HTML to render on the initial load.

## Using with frameworks

One benefit of the custom elements API is that it works not only in plain HTML, but also with [almost every modern web framework](https://custom-elements-everywhere.com/). This allows you to move between frameworks without having to worry about bringing another UI library ever again.

Let's look at some examples of how to use Elements in different frameworks.

### Autocomplete in Svelte

Since `<el-autocomplete>` enhances a regular `<input type="text">` field (similar to a [`<datalist>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/datalist) component), you can use your regular two-way bindings while still getting all the customizability and accessibility you expect in 2025:

```svelte
<script>
  let input = $state("");
  function handleSubmit() {
    alert(`Selected: ${input}`);
  }
</script>

<form onsubmit={handleSubmit}>
  <el-autocomplete>
    <input bind:value={input} name="selected" placeholder="Type to search..." />
    <button aria-label="Show options">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M15.75 19.5L8.25 12l7.5-7.5" />
      </svg>
    </button>
    <el-options transition popover anchor="bottom start">
      <el-option value="Wade Cooper">Wade Cooper</el-option>
      <el-option value="Tom Cooper">Tom Cooper</el-option>
      <el-option value="Jane doe">Jane Doe</el-option>
    </el-options>
  </el-autocomplete>

  <button type="submit">Submit</button>
</form>
```

### Customizeable selects in Rails

`<el-select>` implements a form-associated custom element, so accessing its value in a submitted form works just like native `<select>` elements:

```rb
class OrdersController < ApplicationController
  def new
    @cars = Car.all
    @selected_car = @cars.first
  end

  def create
    car = Car.find(params[:car_id])
    flash[:notice] = "Selected car: #{car.name}"
    redirect_to root_path
  end
end
```

```erb
<%= form_with do |form| %>
  <%= form.label :car_id, "Choose your favorite sports car:" %>

  <el-select name="car_id" id="car_id" value="<%= @selected_car.id %>">
    <button type="button">
      <el-selectedcontent>
        <%= @selected_car.name %>
      </el-selectedcontent>

      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M15.75 19.5L8.25 12l7.5-7.5" />
      </svg>
    </button>

    <el-options anchor="bottom end" popover="">
      <% @cars.each do |car| %>
        <el-option value="<%= car.id %>">
          <%= car.name %>
        </el-option>
      <% end %>
    </el-options>
  </el-select>

  <%= form.submit "Order my sports car" %>
<% end %>
```

### Dropdown menus in Next.js

Of course, you can also use Elements in the most popular framework: React. Because everything is built on standard web technology, you can even use a Next.js `<Link />` components inside `<el-dropdown>` and it just _works_:

```jsx
import Link from "next/link";

export default function Home() {
  return (
    <el-dropdown>
      <button>Menu</button>
      <el-menu anchor="bottom start" popover>
        <Link href="/">Home</Link>
        <Link href="/about">About</Link>
        <Link href="/faq">FAQ</Link>
      </el-menu>
    </el-dropdown>
  );
}
```

## Looking forward

Tailwind Plus Elements is available for all [Tailwind Plus customers](https://tailwindcss.com/plus) starting today and we've updated all of our current components to make full use of it. You can learn more about how to install Tailwind Plus Elements [in our new docs](https://tailwindcss.com/plus/ui-blocks/documentation/elements-api-reference).

With Elements, we now have a way to make all of our Tailwind Plus components work in _any_ framework, designed to become lighter as the web platform itself matures.

We can't wait to see what you'll build with it!
