import { philippspiess } from "@/app/blog/authors";
import card from "./card.jpg";
import Image from "next/image";
import select from "./select.png";
import popover from "./popover.png";
import commandPalette from "./command-palette.png";

export const meta = {
  title: "Vanilla JavaScript support for Tailwind Plus",
  description:
    "We're shipping something that people have been asking for _forever_: Vanilla JavaScript support for our HTML components",
  date: "2025-07-22T18:00:00.000Z",
  authors: [philippspiess],
  image: card,
  excerpt: (
    <>
      When we first launched Tailwind UI back in 2020, we didn't ship any JavaScript with our components at all — they
      were just plain HTML snippets. However, anyone building anything real knows that you need at least some JavaScript
      for things like dropdown menus, dialogs, popovers, and other components like that. Which is why in 2021 we added
      support for React and Vue to our components, using our Headless UI library to power them. But, our plain HTML
      components remained the same — you still had to manually wire up your own JavaScript, and for anyone using
      Rails/Laravel/Svelte etc., that was a real pain.
    </>
  ),
};

This is an exciting week at Tailwind Labs: Not only is it my first anniversary, but we're also shipping something that people have been asking for _forever_: Vanilla JavaScript support for our HTML components.

When we first launched Tailwind UI back in 2020, we didn't ship any JavaScript with our components at all — they were just plain HTML snippets. However, anyone building anything real knows that you need at least some JavaScript for things like dropdown menus, dialogs, popovers, and other components like that. Which is why in 2021 we added support for React and Vue to our components, using our Headless UI library to power them.

But, our plain HTML components remained the same — you still had to manually wire up your own JavaScript, and for anyone using Rails/Laravel/Svelte etc., that was a real pain.

Well, as of today, that's no longer the case.

## Tailwind Plus, without React or Vue

About one fourth of all Tailwind Plus components require some form of interactivity. This includes things like dropdown menus, dialogs, customized selects, and more. If you've been looking at the `HTML`-only version of our snippets in the past, you'd often see instructions on how to manually wire up JavaScript to make these components interactive but no working code. This is changing today.

You can now use all Tailwind Plus components, with full interactivity, without using React or Vue. To do this, we're introducing Tailwind Plus Elements, a new UI library that can be installed by only adding a single script tag to your website.

Let's take a look at some examples.

### Select

Our new custom select component behaves like a native `<select>` tag, including the form association, but allows for much more control over styling. It's inspired by the upcoming [customizable select](https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Customizable_select) APIs making it easy to remove in the future.

<Image src={select} alt="Select" />

```html
<el-select name="selected" value="published">
  <div class="flex ...">
    <el-selectedcontent class="text-sm">Published</el-selectedcontent>
    <button type="button" aria-label="Change published status" class="inline-flex items-center ...">⌄</button>
  </div>

  <el-options anchor="bottom end" popover class="w-72 ...">
    <el-option value="published" class="group/option ...">
      <div class="flex justify-between">
        <p>Published</p>
        <span class="group-not-aria-selected/option:hidden in-[el-selectedcontent]:hidden">✓</span>
      </div>
      <p class="mt-2 text-gray-500 group-focus/option:text-indigo-200 in-[el-selectedcontent]:hidden">
        This job posting can be viewed by anyone who has the link.
      </p>
    </el-option>
    <el-option value="draft" class="group/option ...">
      <div class="flex justify-between">
        <p>Draft</p>
        <span class="group-not-aria-selected/option:hidden in-[el-selectedcontent]:hidden">✓</span>
      </div>
      <p class="mt-2 text-gray-500 group-focus/option:text-indigo-200 in-[el-selectedcontent]:hidden">
        This job posting will no longer be publicly accessible.
      </p>
    </el-option>
  </el-options>
</el-select>
```

### Popover

Our popover element builds upon native the `popover` attribute but adds additional features you'd expect like being able to control that the popover is closing only when the focus leaves a designated popover group.

<Image src={popover} alt="Popover" />

```html
<header>
  <nav aria-label="Global" class="mx-auto flex max-w-6xl ...">
    <el-popover-group class="hidden lg:flex lg:gap-x-12">
      <div class="relative">
        <button popovertarget="desktop-menu-product" class="flex ...">Product</button>
        <el-popover
          id="desktop-menu-product"
          anchor="bottom"
          popover
          class="w-screen max-w-md transition transition-discrete ..."
        >
          <div class="p-4">
            <div class="group relative flex items-center ...">
              <div class="flex-auto">
                <a href="#" class="text-gray-900">Analytics</a>
                <p class="mt-1 text-gray-600">Get a better understanding of your traffic</p>
              </div>
            </div>
            <!-- ... -->
          </div>
        </el-popover>
      </div>
      <a href="#" class="text-sm/6 text-gray-900">Features</a>
      <a href="#" class="text-sm/6 text-gray-900">Marketplace</a>
      <a href="#" class="text-sm/6 text-gray-900">Company</a>
    </el-popover-group>
    <div class="hidden lg:flex lg:flex-1 lg:justify-end">
      <a href="#" class="text-sm/6 text-gray-900">Log in <span aria-hidden="true">→</span></a>
    </div>
  </nav>
</header>
```

### Command palette

One of the trickier components to convert in Tailwind Plus was the command palette examples because of the many interactive pieces. We are pleasantly surprised how nicely a declarative API came together for it:

<Image src={commandPalette} alt="Command Palette" />

```html
<button command="show-modal" commandfor="dialog" class="rounded-md ...">Open command palette</button>

<el-dialog class="group/dialog">
  <dialog id="dialog" class="backdrop:bg-transparent">
    <div class="fixed inset-0 bg-gray-500/25 ..."></div>

    <div tabindex="0" class="fixed inset-0 w-screen ...">
      <el-dialog-panel class="mx-auto transition group-data-closed/dialog:scale-95 ...">
        <el-command-palette>
          <input type="text" autofocus placeholder="Search..." />

          <el-command-list>
            <el-defaults>
              <h2 class="mt-4 text-gray-500">Recent searches</h2>
              <div class="text-sm text-gray-700">
                <a href="#" class="group flex rounded-md ...">
                  <span class="ml-3 truncate">Workflow Inc. / Website Redesign</span>
                </a>
              </div>

              <div class="p-2">
                <h2 class="sr-only">Quick actions</h2>
                <div class="text-sm text-gray-700">
                  <a href="#" class="group flex rounded-md ...">
                    <span class="ml-3 truncate">Add new file...</span>
                  </a>
                  <!-- ... -->
                </div>
              </div>
            </el-defaults>

            <el-command-group hidden class="block p-2 text-sm text-gray-700">
              <a href="#" hidden class="group flex rounded-md ...">
                <span class="ml-3 truncate">Workflow Inc. / Website Redesign</span>
              </a>
              <!-- ... -->
            </el-command-group>
          </el-command-list>

          <el-no-results hidden class="text-center">
            We couldn't find any projects with that term. Please try again.
          </el-no-results>
        </el-command-palette>
      </el-dialog-panel>
    </div>
  </dialog>
</el-dialog>
```

### And so many more

This is just a brief example of some of the components, but as of today, every Tailwind Plus component is now available with full interactivity, regardless the framework you're using.

## Embracing the platform

When building Elements, we've decided early on that we want to lean heavily into the web platform. This allows us to avoid a lot of complexity that's typically required for UI libraries like this in the past. For example: implementing modal dialogs requires managing focus so that you can not target elements behind the dialog — This is something that native `<dialog>` elements can do for free.

Here's an overview of some of the modern browser features that Elements is built on:

- The [`popover` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/popover) to manage overlays and popovers with automatic top-layer rendering together with [the `beforetoggle` event](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/beforetoggle_event) to control transitions.
- Modal [`<dialog>` elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement) for the implementation of focus trapping and top-layer rendering.
- [Invoker commands](https://developer.mozilla.org/en-US/docs/Web/API/Invoker_Commands_API) to declaratively manage interactive elements (like toggling a custom disclosure).
- [Custom elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements) (a way to extend HTML elements with custom behavior) for declarative APIs and [`ElementInternals`](https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals) to manage form association.

We also make sure that appropriate polyfills for these features are added and target [the same browsers that Tailwind CSS v4 supports](https://tailwindcss.com/docs/compatibility#browser-support). In theory, this also means Elements should _only get smaller_ as the web continues to evolve and we have to include fewer polyfills.

There are some additional platform APIs that we're pretty excited about but haven't made it into Elements _yet_. One example is [CSS anchor positioning](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_anchor_positioning) where the required polyfill would unfortunately be too limiting right now so we've decided to use a more established third-party library ([Floating UI](https://floating-ui.com/)) for now.

## Server-side rendering

One of the biggest issues when working with fully declarative APIs in HTML is the lack of control over the server-side rendered output. When you include both a dropdown button _and it's_ content in the initial HTML payload, the first render would include the content of both elements before the JavaScript associated can hide it leading to flashes of unstyled content (FOUC). Frontend libraries can get away with this by changing the DOM at runtime but we wanted elements to work even if you only use a server-side rendered framework.

We designed Elements in a way that allows you to fully control this initial rendering experience and our Tailwind Plus components come with the required properties. Here are some examples:

- Tabs have a `hidden` attribute on unselected tab panels, ensuring that only the default selected tab panel will be visible.
- Dropdown menus, select inputs, popovers, and other components add an explicit `popover` attribute to the HTML snippet, hiding the content on initial load.
- Dialogs include a `<dialog>` element inside the markup for the same reason (the content of a `<dialog>` is hidden by default).
- `<el-selectedcontent>`, an element that is used to render the currently selected content inside the trigger of a select, can be initialized with static HTML to render on the initial load.

## Using with frameworks

One benefit of the custom elements API is that it works not only in plain HTML, but also with [almost every modern web frameworks](https://custom-elements-everywhere.com/). This allows you to move between frameworks without having to worry about bringing another UI library ever again.

Let's look at some examples of how to use Elements in different frameworks.

### Autocomplete in Svelte

Since `<el-autocomplete>` enhances a regular `<input type="text">` field (similar to a [`<datalist>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/datalist) component), you can use your regular two-way bindings while still getting all the customizability and accessibility you expect in 2025:

```svelte
<script>
  let input = $state("");
  function handleSubmit() {
    alert(`Selected: ${input}`);
  }
</script>

<form onsubmit={handleSubmit}>
  <el-autocomplete>
    <input bind:value={input} name="selected" placeholder="Type to search..." />
    <button aria-label="Show options">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M15.75 19.5L8.25 12l7.5-7.5" />
      </svg>
    </button>
    <el-options transition popover anchor="bottom start">
      <el-option value="Wade Cooper">Wade Cooper</el-option>
      <el-option value="Tom Cooper">Tom Cooper</el-option>
      <el-option value="Jane doe">Jane Doe</el-option>
    </el-options>
  </el-autocomplete>

  <button type="submit">Submit</button>
</form>
```

### Customizeable selects in Rails

`<el-select>` implements a form-associated custom element, so accessing it's value in a submitted form works just like native `<select>` elements:

```rb
class OrdersController < ApplicationController
  def new
    @cars = Car.all
    @selected_car = @cars.first
  end

  def create
    car = Car.find(params[:car_id])
    flash[:notice] = "Selected car: #{car.name}"
    redirect_to root_path
  end
end
```

```erb
<%= form_with do |form| %>
  <%= form.label :car_id, "Choose your favorite sports car:" %>

  <el-select name="car_id" id="car_id" value="<%= @selected_car.id %>">
    <button type="button">
      <el-selectedcontent>
        <%= @selected_car.name %>
      </el-selectedcontent>

      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M15.75 19.5L8.25 12l7.5-7.5" />
      </svg>
    </button>

    <el-options anchor="bottom end" popover="">
      <% @cars.each do |car| %>
        <el-option value="<%= car.id %>">
          <%= car.name %>
        </el-option>
      <% end %>
    </el-options>
  </el-select>

  <%= form.submit "Order my sports car" %>
<% end %>
```

### Dropdown menus in Next.js

Of course, you can also use Elements in the most popular framework: React. Because everything is built on standard web technology, you can even use a Next.js `<Link />` components inside `<el-dropdown>` and it just _works_:

```jsx
import Link from "next/link";

export default function Home() {
  return (
    <el-dropdown>
      <button>Menu</button>
      <el-menu anchor="bottom start" popover>
        <Link href="/">Home</Link>
        <Link href="/about">About</Link>
        <Link href="/faq">FAQ</Link>
      </el-menu>
    </el-dropdown>
  );
}
```

## Looking forward

Tailwind Plus Elements is available for all [Tailwind Plus customers](https://tailwindcss.com/plus) starting today and we've updated all of our current components to make full use of it. You can learn more about how to install Tailwind Plus Elements [in our new docs](https://tailwindcss.com/plus/ui-blocks/documentation/elements-api-reference).

With Elements, we now have a way to make all of our Tailwind Plus components work in _any_ framework, designed to become lighter as the web platform itself matures.

We can't wait to see what you'll build with it!
